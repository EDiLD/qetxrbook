# ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#! status : in works
```

## First steps in R

R is a powerful calculator with standard arithmetic operators:

```{r}
# Addition
1 + 6
```

```{r}
# Multiplication
2 * 6
```

```{r}
# multiplication and division first, then addition and subtraction
2 * 6 + 1
```

```{r}
# use of brackets
2 * (6 + 1)
```

```{r}
# square root
sqrt(16)
```

```{r}
# powers
16^0.5
2^2
```

```{r}
# natural log
log(10)
```

```{r}
# decadic log
log10(10)
```

```{r}
# log to base of 4
log(10, 4)
```

```{r}
# exponential
exp(2)
```

```{r error=TRUE}
# pi is a built-in constant
pi
# but not e
e^2
```








If we want to refer to a result later on, we can give them a name.

```{r}
a <- 1 + 6
```

Here I *assign* (`<-`) the result of `1 + 6` to an *object* named `a`.
If you just type the name into the console R shows whats inside this object:

```{r}
a
```

You can also do calculations with this object:

```{r}
2 * a
```

Note, that R will overwrite objects:
```{r}
a
a <- 2*a
a
```

If R doesn't know about an object you get the following error:
```{r error=TRUE}
b
```

which says: *"I looked for the object 'b', but could not find it"*".

You can see objects that are available in the `Environment` pane of RStudio. Alternatively you can use the `ls()` function.




## Data types in R

Before starting with data analyses we need to know which types of data R can handle.
Here we discuss only the basic types `numeric`, `integer`, `character` and `logical`.


### Numerics
We already encountered the *numeric* data type in the previous section:

```{r}
a <- 2.5
```

We can check what type an object is with the class function

```{r}
class(a)
```

Note that integers are also stored as numeric:

```{r}
b <- 2
class(b)
```

We can also confirm the type of an object using the `is.*()` functions (where * is a placeholder for `numeric`, `integer`, `logical` or `character`).

```{r}
is.numeric(b)
is.integer(b)
```


### Integers

There isn't a big practical difference between integers and numeric in R. However, it is useful to know about them.

To specify an integer object we need to add `L` to the integer:

```{r}
c <- 2L
class(c)
```

We can also convert a numeric to integer using the `as.integer()` function.

```{r}
b
class(b)
d <- as.integer(b)
d
class(d)
```

There are also equivalent `as.*()` functions for `numeric`, `logical` or `character`.
However, be careful we converting numerics:
```{r results='hold'}
as.integer(6.23)
as.integer(6.7)
```

Also converting strings make no sense
```{r}
as.integer('Hello World')
```

and R returns `NA` accomnied with a warning that it cannot coerce to a integer.


### Characters

Character objects are used to represent string values in R:

```{r}
a <- 'Hello World'
class(a)
```

We can always coerce integers and numerics to characters:


```{r results='hold'}
as.character(2L)
as.character(2.6)
```

and also sometimes (when possible) the way round:

```{r}

as.numeric(as.character(2.6))
as.numeric('Hello World')
```

With `numeric` and `integers` we can do arithmetics,
```{r, results='hold'}
2 + 1
2L + 1
```

, but not with `charactars` this is meaningless and gives this error

```{r error=TRUE}
'Hello world' + 1
```



### Logicals

We already encoutered logicals when checking objects with the `is.*()` function. 
This function returned either `TRUE` or `FALSE`. 
Logicals are also returned when comparing two numerics

```{r results='hold'}
2 < 3  # is 2 smaller then 3?
5 > 6  # is 5 bigger the 6
5 > 5 # is 5 greater then 5
5 >= 5 # is 5 greater or equal then 5
```

Logical operators in R are `&` (AND), `|` OR and `!` (negotiation):


```{r results='hold'}
TRUE & TRUE
TRUE & FALSE
FALSE & TRUE
FALSE & FALSE
```

```{r results='hold'}
TRUE | TRUE
TRUE | FALSE
FALSE | TRUE
FALSE | FALSE
```

```{r results='hold'}
TRUE
!TRUE
```


Logicals can be coerced to *integers* or *numerics*, with `TRUE` beeing mapped to 1 and `FALSE` to 0.

```{r}
as.numeric(TRUE)
```

This is handy because we can also calculated the sum:

```{r}
TRUE + TRUE
```

```{r}
3*TRUE + FALSE + TRUE
```


### Factors
Factors are a fourth, more special, data type in R. 
You can think of factors as special character vectors with some nice additional functions.

You can create factors using the `factor` function:
```{r}
fac <- factor(c('A', 'A', 'B', 'B'))
class(fac)
fac
```

From the output you see that factors store another information: the `levels` of the data. 

In fact R stores them internally as integers and only labels these integers according to it's levels.
Therefore, `as.numeric() return a vector of these internal integers:

```{r}
as.numeric(fac)
```

and not an error like above with character vectors.

Be careful with numeric factors!
While for character vectors that can be coerced to numeric, Â´as.numeric` returns the desired result


```{r}
char <- c('2', '2', '3', '3')
as.numeric(char)
```

this is not the case for factors:

```{r}
as.numeric(factor(char))
```

Here it returns the internal integer value (these are ordered by alphabet).

To return the desired result, first coerce to character (making R to forget about the levels) and then to numeric.

```{r}
as.numeric(as.character(factor(char)))
```


You can access the levels of a factor using the `levels()` fucntion:

```{r}
levels(fac)
```


Factors are useful for categorical data and we will encounter them later on when dealing with linear models. For now just keep in mind that factors are special characters, with special properties.




## Data structures in R
### Vectors

Vectors are the basic data structure in R. 
Vectors are one-dimensional structures (remember linear algebra from school?) and all numbers that we typed above were vectors with the lenght of one.
We can query the length of a vector using `length()`

```{r}
# this is a vector of lenght 1
25
length(25)
```

We can create vectors using the `c()` function (short for *combine*):

```{r}
num_vec <- c(25, 1, 3, 6)
num_vec
length(num_vec)
```

Or logical vectors:

```{r}
log_vec <- c(TRUE, FALSE, FALSE, TRUE, TRUE)
log_vec
length(log_vec)
class(log_vec)
```

Note that all elements must be of the same type. 
If we combine elements from different type the whole vector will be coerced to the lowest type (`logical` > `integer` > `numeric` > `character`):

```{r}
a <- c(TRUE, 2L, 2.5, 'hello')
a
class(a)

b <- c(TRUE, 2L, 2.5)
b
class(b)

c <- c(FALSE, 'hello')
class(c)
```

We can also do math with vectors:

```{r}
num_vec <- c(1, 2, 3)
num_vec
```

```{r}
# elementwise addition
num_vec + 2
```

```{r}
# elementwise power
num_vec^2
```

```{r}
# sum of vector elements
sum(num_vec)
```

```{r}
# mean of vector
sum(num_vec) / length(num_vec)
# or directly suing the mean() function
mean(num_vec)
```


Often, we need to create sequences of numbers.
Here the `seq()` function is handy, it take at least two arguments `from` and `to`

```{r}
# sequence from 2 to 10
seq(from = 2, to = 10)
# sequence from 10 to 3
seq(from = 10, to = 3)
```

A shortcut for such sequences with steps of 1 or -1 is the colon operator `:`

```{r}
# sequence from 2 to 10
2:10
# sequence from 10 to 3
10:3
```

The colon operator will be very handy later on. 
However, `seq` is much more flexibel as we can change the stepsize

```{r}
# sequence from 2 to 5 in steps of 0.5
seq(from = 2, to = 5, by = 0.5)
```

Or specify the length of the sequence

```{r}
# sequence from 2 in steps of 0.5 with length of 5
seq(from = 2, by = 0.5, length.out = 5)
```

Note, that we can omit the argument names, but the R assumes that the arguments passed are in the correct order:

```{r}
# sequence from 2 to 5 in steps of 0.5
seq(2, 5, 0.5)
```

Howevr this does not give the inteded results, because 5 is interpreted as `by` argument (third position).
```{r error=TRUE}
# intended result: sequence from 2 in steps of 0.5 with length of 5
seq(2, 0.5, 5)
```



Another useful fucntion is the replicate function `rep()`:


```{r}
# repeats the vector hello 3 times
rep('hello', times = 3)
```

```{r}
# repeats the vector c('hello', 'world') 3 times
rep(c('hello', 'world'), times = 3)
```

If we want to repeat each vector element we need to use the `each` argument:


```{r}
# repeats each element of the vector c('hello', 'world') 3 times
rep(c('hello', 'world'), each = 3)
```




### Matrices

Matrices are the 2-dimensional extension of vectors. 

We can combine two vectors to a matrix using `cbind` (combine by columns) or `rbind` combine by rows:

```{r}
vec1 <- 1:5
vec2 <- rep(9, 5)
# combine by columns
mat1 <- cbind(vec1, vec2)
mat1
# combine by rows
mat2 <- rbind(vec1, vec2)
mat2
class(mat2)
```

Similar, to the `length` function for vectors, there is a dimension function for matrices

```{r}
dim(mat1) # 5 rows, 2 columns
dim(mat2) # 2 rows, 5 columns
```

As with vectors, all elements in a matrix must be of same type. If not the are coerced downwards.

```{r}
cbind(c(1, 3), 
  c('hello', 'world'))
```

An we can do elementwise arithmetic

```{r}
mat1 + 10
sqrt(mat1)
```

Matrices can be also created with the `matrix()` function:


```{r}
rot <- matrix(c(0, 1, 
                1, 0), ncol = 2, byrow = TRUE)
```



### Data.frames
The constrained of matrices having all data of same type is not very appealing for data analysis, where we might have different variable types in one data sheet (e.g numeric descriptors and categorical descriptors). 
Nevertheless, matrices and matrix algebra playa a central role in R's computations.

A `data.frame` in another, more flexibel, 2-dimensional data structure. 
In fact, it will be your mostly used structure. 
`data.frames` allow different types of variables, but all must be of the same lenght.

You can create data.frames using the `data.frame()` function:

```{r}
df <- data.frame(1:5, c('A', 'A', 'A', 'B', 'B'))
df
```




### Lists
