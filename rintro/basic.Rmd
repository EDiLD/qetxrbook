```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#! status : in works
```

## First steps in R

R is a powerful calculator with standard arithmetic operators:

```{r}
# Addition
1 + 6
```

```{r}
# Multiplication
2 * 6
```

```{r}
# multiplication and division first, then addition and subtraction
2 * 6 + 1
```

```{r}
# use of brackets
2 * (6 + 1)
```

```{r}
# square root
sqrt(16)
```

```{r}
# powers
16^0.5
2^2
```

```{r}
# natural log
log(10)
```

```{r}
# decadic log
log10(10)
```

```{r}
# log to base of 4
log(10, 4)
```

```{r}
# exponential
exp(2)
```

```{r error=TRUE}
# pi is a built-in constant
pi
# but not e
e^2
```








If we want to refer to a result later on, we can give them a name.

```{r}
a <- 1 + 6
```

Here I *assign* (`<-`) the result of `1 + 6` to an *object* named `a`.
If you just type the name into the console R shows whats inside this object:

```{r}
a
```

You can also do calculations with this object:

```{r}
2 * a
```

Note, that R will overwrite objects:
```{r}
a
a <- 2*a
a
```

If R doesn't know about an object you get the following error:
```{r error=TRUE}
b
```

which says: *"I looked for the object 'b', but could not find it"*".

You can see objects that are available in the `Environment` pane of RStudio. Alternatively you can use the `ls()` function.




## Data types in R

Before starting with data analyses we need to know which types of data R can handle.
Here we discuss only the basic types `numeric`, `integer`, `character` and `logical`.


### Numerics
We already encountered the *numeric* data type in the previous section:

```{r}
a <- 2.5
```

We can check what type an object is with the class function

```{r}
class(a)
```

Note that integers are also stored as numeric:

```{r}
b <- 2
class(b)
```

We can also confirm the type of an object using the `is.*()` functions (where * is a placeholder for `numeric`, `integer`, `logical` or `character`).

```{r}
is.numeric(b)
is.integer(b)
```


### Integers

There isn't a big practical difference between integers and numeric in R. However, it is useful to know about them.

To specify an integer object we need to add `L` to the integer:

```{r}
c <- 2L
class(c)
```

We can also convert a numeric to integer using the `as.integer()` function.

```{r}
b
class(b)
d <- as.integer(b)
d
class(d)
```

There are also equivalent `as.*()` functions for `numeric`, `logical` or `character`.
However, be careful we converting numerics:
```{r results='hold'}
as.integer(6.23)
as.integer(6.7)
```

Also converting strings make no sense
```{r}
as.integer('Hello World')
```

and R returns `NA` accomnied with a warning that it cannot coerce to a integer.


### Characters

Character objects are used to represent string values in R:

```{r}
a <- 'Hello World'
class(a)
```

We can always coerce integers and numerics to characters:


```{r results='hold'}
as.character(2L)
as.character(2.6)
```

and also sometimes (when possible) the way round:

```{r}

as.numeric(as.character(2.6))
as.numeric('Hello World')
```

With `numeric` and `integers` we can do arithmetics,
```{r, results='hold'}
2 + 1
2L + 1
```

, but not with `charactars` this is meaningless and gives this error

```{r error=TRUE}
'Hello world' + 1
```



### Logicals

We already encoutered logicals when checking objects with the `is.*()` function. 
This function returned either `TRUE` or `FALSE`. 
Logicals are also returned when comparing two numerics

```{r results='hold'}
2 < 3  # is 2 smaller then 3?
5 > 6  # is 5 bigger the 6
5 > 5 # is 5 greater then 5
5 >= 5 # is 5 greater or equal then 5
```

Logical operators in R are `&` (AND), `|` OR and `!` (negotiation):


```{r results='hold'}
TRUE & TRUE
TRUE & FALSE
FALSE & TRUE
FALSE & FALSE
```

```{r results='hold'}
TRUE | TRUE
TRUE | FALSE
FALSE | TRUE
FALSE | FALSE
```

```{r results='hold'}
TRUE
!TRUE
```


Logicals can be coerced to *integers* or *numerics*, with `TRUE` beeing mapped to 1 and `FALSE` to 0.

```{r}
as.numeric(TRUE)
```

This is handy because we can also calculated the sum:

```{r}
TRUE + TRUE
```

```{r}
3*TRUE + FALSE + TRUE
```




## Data structures in R


### Vectors

Vectors are the basic data structure in R. 
Vectors are one-dimensional structures (remember linear algebra from school?) and all numbers that we typed above were vectors with the lenght of one.
We can query the length of a vector using `length()`

```{r}
# this is a vector of lenght 1
25
length(25)
```

We can create vectors using the `c()` function (short for *combine*):

```{r}
num_vec <- c(25, 1, 3, 6)
num_vec
length(num_vec)
```

Or logical vectors:

```{r}
log_vec <- c(TRUE, FALSE, FALSE, TRUE, TRUE)
log_vec
length(log_vec)
class(log_vec)
```

Note that all elements must be of the same type. 
If we combine elements from different type the whole vector will be coerced to the lowest type (`logical` > `integer` > `numeric` > `character`):

```{r}
a <- c(TRUE, 2L, 2.5, 'hello')
a
class(a)

b <- c(TRUE, 2L, 2.5)
b
class(b)

c <- c(FALSE, 'hello')
class(c)
```

We can also do math with vectors:

```{r}
num_vec <- c(1, 2, 3)
num_vec
```

```{r}
# elementwise addition
num_vec + 2
```

```{r}
# elementwise power
num_vec^2
```

```{r}
# sum of vector elements
sum(num_vec)
```

```{r}
# mean of vector
sum(num_vec) / length(num_vec)
# or directly suing the mean() function
mean(num_vec)
```


Often, we need to create sequences of numbers.
Here the `seq()` function is handy, it take at least two arguments `from` and `to`

```{r}
# sequence from 2 to 10
seq(from = 2, to = 10)
# sequence from 10 to 3
seq(from = 10, to = 3)
```

A shortcut for such sequences with steps of 1 or -1 is the colon operator `:`

```{r}
# sequence from 2 to 10
2:10
# sequence from 10 to 3
10:3
```

The colon operator will be very handy later on. 
However, `seq` is much more flexibel as we can change the stepsize

```{r}
# sequence from 2 to 5 in steps of 0.5
seq(from = 2, to = 5, by = 0.5)
```

Or specify the length of the sequence

```{r}
# sequence from 2 in steps of 0.5 with length of 5
seq(from = 2, by = 0.5, length.out = 5)
```

Note, that we can omit the argument names, but the R assumes that the arguments passed are in the correct order:

```{r}
# sequence from 2 to 5 in steps of 0.5
seq(2, 5, 0.5)
```

Howevr this does not give the inteded results, because 5 is interpreted as `by` argument (third position).
```{r error=TRUE}
# intended result: sequence from 2 in steps of 0.5 with length of 5
seq(2, 0.5, 5)
```



Another useful fucntion is the replicate function `rep()`:


```{r}
# repeats the vector hello 3 times
rep('hello', times = 3)
```

```{r}
# repeats the vector c('hello', 'world') 3 times
rep(c('hello', 'world'), times = 3)
```

If we want to repeat each vector element we need to use the `each` argument:


```{r}
# repeats each element of the vector c('hello', 'world') 3 times
rep(c('hello', 'world'), each = 3)
```




### Matrices

### Data.frames

### Lists
